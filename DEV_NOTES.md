# DEV Notes

## Modules

### `agent-parksuite-biz-api`
- Tech: FastAPI + SQLAlchemy async + PostgreSQL(JSONB)
- Purpose: parking billing rule configuration/query, parking order query, arrears query, fee simulation
- Entry: `src/agent_parksuite_biz_api/main.py`
- Key files:
  - API: `src/agent_parksuite_biz_api/api/routes.py`
  - Models: `src/agent_parksuite_biz_api/db/models.py`
  - Billing engine: `src/agent_parksuite_biz_api/services/billing_engine.py`
  - Schemas: `src/agent_parksuite_biz_api/schemas/billing.py`, `src/agent_parksuite_biz_api/schemas/order.py`

### `agent-parksuite-rag-core`
- Tech: FastAPI + SQLAlchemy async + PostgreSQL + pgvector
- Purpose: RAG core skeleton (knowledge chunk storage + retrieve API placeholder)
- Entry: `src/agent_parksuite_rag_core/main.py`
- Key files:
  - API: `src/agent_parksuite_rag_core/api/routes.py`
  - Models: `src/agent_parksuite_rag_core/db/models.py`
  - Session/init: `src/agent_parksuite_rag_core/db/session.py`
- Next design scope:
  - Rule explanation for user questions (how fees are calculated)
  - Evidence-backed responses with source/version/effective time
  - Hybrid flow with biz tools for arrears check and fee verification

## Biz API PR List

### BIZ-001: Project bootstrap and dependency baseline
- Add monorepo layout, package config, test config
- Add shared dependencies (FastAPI/Pydantic/LangChain stack + SQLAlchemy + asyncpg + pgvector)
- Files:
  - `pyproject.toml`
  - `README.md`
  - `.env.example`

### BIZ-002: Biz API app skeleton and DB initialization
- Add Biz API startup entry and health endpoint
- Add async session factory
- Files:
  - `src/agent_parksuite_biz_api/main.py`
  - `src/agent_parksuite_biz_api/config.py`
  - `src/agent_parksuite_biz_api/db/base.py`
  - `src/agent_parksuite_biz_api/db/session.py`

### BIZ-003: Billing rule domain model refactor (rule + version)
- Replace single billing rule design with:
  - `billing_rules` (identity/scope/status)
  - `billing_rule_versions` (effective time ranges + payload)
- Add JSONB scope and `lot_codes` support
- Add GIN index for scope query and unique constraint on `(rule_id, version_no)`
- Files:
  - `src/agent_parksuite_biz_api/db/models.py`
  - `src/agent_parksuite_biz_api/schemas/billing.py`
  - `src/agent_parksuite_biz_api/schemas/order.py`

### BIZ-004: Billing rule APIs and versioned simulation
- Implement APIs:
  - `POST /api/v1/billing-rules` (upsert rule + append version)
  - `GET /api/v1/billing-rules`
  - `GET /api/v1/billing-rules/{rule_code}`
  - `POST /api/v1/billing-rules/simulate`
- Add overlap guard for version effective ranges
- Add scope filtering by `city_code` and `lot_code` (JSONB contains)
- Files:
  - `src/agent_parksuite_biz_api/api/routes.py`

### BIZ-005: Parking order and arrears query APIs
- Implement APIs:
  - `POST /api/v1/parking-orders`
  - `GET /api/v1/parking-orders/{order_no}`
  - `GET /api/v1/arrears-orders`
- Add arrears amount calculation on create
- Files:
  - `src/agent_parksuite_biz_api/api/routes.py`
  - `src/agent_parksuite_biz_api/schemas/order.py`
  - `src/agent_parksuite_biz_api/db/models.py`

### BIZ-006: Billing engine enhancement (payload-driven)
- Support `periodic`, `tiered`, `free` segments by `rule_payload`
- Support cross-day time windows (e.g. `20:00-08:00`)
- Support non-divisible unit rounding (ceil charging)
- Change cap logic to daily cap per segment/time_window reset by day
- Files:
  - `src/agent_parksuite_biz_api/services/billing_engine.py`

### BIZ-007: Billing engine test scenarios
- Add/refresh unit tests:
  - periodic with free minutes + cap
  - periodic non-divisible unit rounding
  - periodic across days with daytime cap reset
  - day+night periodic with independent caps
  - tiered across days + night free (including end at 08:29 case)
- Files:
  - `tests/biz_api/test_billing_engine_unit.py`

### BIZ-008: Alembic migration baseline (Doc + Implementation)
- Goal:
  - Introduce versioned DB schema migration workflow
  - Provide initial migration that matches current SQLAlchemy models
- Scope:
  - Add Alembic config and environment wiring
  - Add initial migration to create biz/rag tables and key constraints/indexes
  - Document migration commands and usage
- Deliverables:
  - `alembic.ini`
  - `alembic/env.py`
  - `alembic/script.py.mako`
  - `alembic/versions/<rev>_biz_init_schema.py`
  - `alembic/versions/<rev>_rag_init_schema.py`
  - README updates (migration section)
- Acceptance:
  - `alembic upgrade head` can build schema from empty DB
  - `alembic downgrade base` can roll back initial schema

### BIZ-009: Biz API route integration tests and test-data policy
- Add route-level integration tests for billing and order APIs
- Add test fixtures for dedicated DB, dependency override, and per-test isolation
- Add optional `KEEP_TEST_DATA=1` to preserve test tables/data for debugging
- Use unique test identifiers to avoid collisions when keeping historical test data
- Files:
  - `tests/biz_api/conftest.py`
  - `tests/biz_api/test_routes_billing_integration.py`
  - `tests/biz_api/test_routes_orders_integration.py`
  - `README.md`

## Rag Core PR Plan

### RAG-000: Biz scenario dataset baseline (pre-RAG)
- Build a deterministic business scenario dataset from `biz-api` domain:
  - billing rules (multi-version, multi-lot)
  - parking orders (paid/unpaid/arrears)
  - simulation snapshots for verification cases
- Define scenario IDs and expected facts for each case:
  - expected arrears status
  - expected simulated amount
  - expected rule version hit
- Add export format for downstream RAG generation:
  - JSON/JSONL with scenario metadata and expected outputs
- Acceptance:
  - one command can initialize scenario dataset in test DB
  - scenario facts are reproducible and can be used as eval baseline
- Implementation entry:
  - `scripts/rag000_seed_biz_scenarios.py`

#### RAG-000 Data Dictionary
- `scenario_id`: stable unique ID, e.g. `SCN-001`
- `intent_tags`: one or more tags:
  - `rule_explain`
  - `arrears_check`
  - `fee_verify`
- `query`: natural language user question
- `context`:
  - `city_code`
  - `lot_code`
  - `plate_no`
  - `order_no` (optional)
  - `entry_time`
  - `exit_time`
- `expected_tools`: expected biz-api calls, e.g.
  - `GET /api/v1/arrears-orders`
  - `GET /api/v1/parking-orders/{order_no}`
  - `POST /api/v1/billing-rules/simulate`
- `ground_truth`:
  - `matched_rule_code`
  - `matched_version_no`
  - `expected_total_amount`
  - `order_total_amount`
  - `amount_check_result` (`一致`/`不一致`)
  - `amount_check_action` (`自动通过`/`需人工复核`)
  - `expected_paid_amount`
  - `expected_arrears_amount`
  - `expected_arrears_status` (`NONE`/`HAS_ARREARS`)
- `expected_citations`:
  - `doc_type` (`rule_explain`/`policy_doc`/`faq`/`sop`)
  - `source_ids` (one or more chunk/source IDs)
- `notes`: boundary condition or special check description

#### RAG-000 Scenario Set (20 cases)
- `SCN-001` 周期计费-整除:
  - 08:00-09:00, 30分钟2元, 预期4元
- `SCN-002` 周期计费-非整除进位:
  - 08:00-09:05, 30分钟2元, 预期6元
- `SCN-003` 日间封顶:
  - 08:00-20:00+, 日间封顶20元, 预期20元
- `SCN-004` 跨天日间封顶重置:
  - 连续多天停车, 每天日间封顶独立重置
- `SCN-005` 夜间免费:
  - 20:00-08:00 免费, 仅夜间停车预期0元
- `SCN-006` 日夜组合:
  - 日间收费+夜间免费, 校验分段金额
- `SCN-007` 阶梯计费:
  - 首2小时每半小时2元, 之后每半小时3元
- `SCN-008` 首30分钟免费边界:
  - 29/30/31分钟三个订单对比
- `SCN-009` 欠费判断:
  - 同车牌含已支付、部分支付、未支付订单
- `SCN-010`~`SCN-011`:
  - 首30分钟免费边界补足（30分钟/31分钟）
- `SCN-012`:
  - 日夜双时段组合，日间与夜间各自封顶
- `SCN-013`~`SCN-014`:
  - 阶梯计费2小时内/外差异
- `SCN-015`~`SCN-016`:
  - 规则版本切换（生效前后）
- `SCN-017`~`SCN-018`:
  - 同城不同 `lot_code` 差异
- `SCN-019`:
  - 计费核验一致（订单金额=模拟金额）
- `SCN-020`:
  - 计费核验异常（订单金额!=模拟金额，结论“需人工复核”）

#### RAG-000 Seed Expected Counts
- `billing_rules`: 5
- `billing_rule_versions`: 6
- `parking_orders`: 22
- `scenarios.jsonl`: 20

#### RAG-000 Coverage Matrix
- Time boundaries:
  - `07:59`, `08:00`, `19:59`, `20:00`, `20:01`
- Cross-day boundary:
  - `23:59 -> 00:01`
- Version boundary:
  - `effective_from` hit at exact timestamp
- Cap boundary:
  - equal to cap
  - exceed cap by one billing unit

### RAG-001: RAG data model and storage upgrade
- Extend `rag-core` schema with metadata for retrieval filtering:
  - `doc_type`, `city_code`, `lot_codes`, `effective_from`, `effective_to`, `source`, `version`
- Add indexes for metadata filtering + vector search
- Input source aligned with `RAG-000` outputs (`source_type=biz_derived`)
- Acceptance:
  - can insert and query knowledge chunks with metadata filters
- Implemented:
  - data model:
    - `knowledge_sources.source_type` (default `biz_derived`)
    - `knowledge_chunks` ivfflat vector index (`vector_cosine_ops`)
  - APIs:
    - `POST /api/v1/knowledge/sources` (upsert metadata)
    - `POST /api/v1/knowledge/chunks/batch` (batch ingest with dim check)
    - `POST /api/v1/retrieve` (filter by `city_code/lot_code/at_time/doc_type/source_type/source_ids`)
  - files:
    - `src/agent_parksuite_rag_core/db/models.py`
    - `alembic/versions/20260223_0002_rag_init_schema.py`
    - `src/agent_parksuite_rag_core/schemas/rag.py`
    - `src/agent_parksuite_rag_core/api/routes.py`
    - `tests/rag_core/conftest.py`
    - `tests/rag_core/test_routes_rag_integration.py`

### RAG-002: Ingestion pipeline
- Add ingestion flow: clean text -> chunk -> embedding -> upsert
- Support batch import from JSONL/Markdown sources
- Support derived knowledge generation from biz scenarios:
  - rule explanation text
  - scenario-based FAQ
  - fee calculation walk-through snippets
- Acceptance:
  - imported knowledge is retrievable and traceable by source/version
- Implemented:
  - service:
    - `src/agent_parksuite_rag_core/services/ingestion.py`
    - scenarios JSONL -> source/chunk draft generation
    - markdown -> source/chunk draft generation
    - deterministic embedder (default) + OpenAI embedder (optional)
    - DB upsert for `knowledge_sources` + `knowledge_chunks`
  - script:
    - `scripts/rag002_ingest_knowledge.py`
    - supports `--input-type scenarios_jsonl|markdown`
    - supports `--embedding-provider deterministic|openai`
  - tests:
    - `tests/rag_core/test_ingestion_pipeline_unit.py`

### RAG-003: Retrieve API (RAG retrieval core)
- Implement `POST /api/v1/retrieve`
- Support filters:
  - `city_code`, `lot_code`, `at_time`, `doc_type`, `top_k`
- Ensure retrieval prefers dataset-aligned chunks for scenario-based queries
- Acceptance:
  - retrieval honors metadata constraints and returns stable top-k results
- Repository refactor (pre-service split):
  - add `src/agent_parksuite_rag_core/repositories/knowledge.py`
  - move DB read/write logic for source/chunk/retrieve out of API layer
  - API layer now focuses on request validation + HTTP error mapping + response composition
- Implemented:
  - route:
    - `src/agent_parksuite_rag_core/api/routes.py`
    - supports filter constraints: `doc_type/source_type/city_code/lot_code/source_ids/at_time/include_inactive`
    - supports vector ranking when `query_embedding` provided
    - supports lexical preference ranking (no embedding) for scenario-style queries
    - deterministic tie-break ordering for stable top-k
  - tests:
    - `tests/rag_core/test_routes_rag_integration.py`
    - coverage for metadata/time filters
    - coverage for lexical preference without embedding
    - coverage for stable ordering under tied vector scores

### RAG-004: Answer API (RAG-only)
- Implement `POST /api/v1/answer` for explanation-style questions
- Output format:
  - conclusion + key points + cited chunks/sources
- Acceptance:
  - responses include usable citation fields and evidence snippets
- Implemented:
  - route:
    - `src/agent_parksuite_rag_core/api/routes.py`
    - `POST /api/v1/answer` reuses retrieve filters and returns answer+citation payload
  - service:
    - `src/agent_parksuite_rag_core/services/answering.py`
    - integrates DeepSeek via OpenAI-compatible endpoint (`ChatOpenAI`)
    - output contract: conclusion + key_points (JSON-first, fallback to raw text)
  - schema/config:
    - `src/agent_parksuite_rag_core/schemas/rag.py` (`AnswerRequest/AnswerResponse/AnswerCitation`)
    - `src/agent_parksuite_rag_core/config.py` (`deepseek_api_key/base_url/model`)
  - tests:
    - `tests/rag_core/test_routes_answer_integration.py` (mocked LLM success/503 path)

### RAG-005: Hybrid orchestration (RAG + biz tools)
- Introduce LangGraph-based orchestration for hybrid answering:
  - graph nodes (target): intent_classifier -> {rule_explain_flow | arrears_check_flow | fee_verify_flow} -> answer_synthesizer
  - use conditional edges to make branch path explicit and traceable
  - keep graph minimal and auditable for later RAG-007/RAG-008 expansion
- Use LLM-driven intent routing with rule fallback:
  - LLM classifier outputs one of: `rule_explain` / `arrears_check` / `fee_verify`
  - invalid or low-confidence outputs fallback to rule-based routing for determinism
- Branch definitions:
  - `rule_explain` -> RAG-only explanation flow
  - `arrears_check` -> arrears tool (+ optional RAG evidence) flow
  - `fee_verify` -> parking-order + billing-simulate + RAG evidence flow
- Integrate biz tool outputs into answer composition for:
  - arrears check
  - fee verification
- Split final response into:
  - business facts (tool result)
  - rule/policy evidence (RAG result)
  - final conclusion (LLM synthesis over facts + evidence)
- Acceptance:
  - routing is primarily LLM-driven, with deterministic fallback
  - verification answers contain both computed facts and explainable references
  - graph execution path is traceable (node order/status, selected branch)
- Biz tool scope (MVP):
  - `GET /api/v1/arrears-orders`
    - intent: `arrears_check`
    - purpose: query arrears orders by `plate_no/city_code`
  - `GET /api/v1/parking-orders/{order_no}`
    - intent: `fee_verify`
    - purpose: fetch order-side business facts (`total_amount/paid_amount/arrears_amount`)
  - `POST /api/v1/billing-rules/simulate`
    - intent: `fee_verify`
    - purpose: simulate expected amount from rule payload for verification
  - `GET /api/v1/billing-rules` or `GET /api/v1/billing-rules/{rule_code}`
    - intent: `rule_explain` (optional structured supplement)
    - purpose: fetch configured rule metadata/version context
- Intent -> tool mapping (target):
  - `rule_explain`: RAG first, optional billing-rule lookup
  - `arrears_check`: arrears-orders tool + optional RAG evidence
  - `fee_verify`: parking-order detail + billing simulate + RAG evidence
- Implemented:
  - route:
    - `src/agent_parksuite_rag_core/api/routes.py`
    - `POST /api/v1/answer/hybrid` as thin route:
      - request mapping + invoke service orchestrator + response assembly
  - service:
    - `src/agent_parksuite_rag_core/services/hybrid_answering.py`
      - LLM intent classifier with deterministic fallback
      - invokes tools for `arrears_check` / `fee_verify` facts
      - invokes workflow runner
  - `src/agent_parksuite_rag_core/clients/biz_api_client.py` (biz-api client wrappers)
  - tools:
    - `src/agent_parksuite_rag_core/tools/biz_fact_tools.py`
    - wraps biz-client calls into workflow-facing tool functions
    - `src/agent_parksuite_rag_core/services/answering.py` (`generate_hybrid_answer`)
  - workflow:
    - `src/agent_parksuite_rag_core/workflows/hybrid_answer.py`
    - LangGraph conditional-branch topology:
      - `intent_classifier`
      - `rule_explain_flow -> rag_retrieve -> answer_synthesizer`
      - `arrears_check_flow -> answer_synthesizer`
      - `fee_verify_flow -> rag_retrieve -> answer_synthesizer`
  - schema/config:
    - `src/agent_parksuite_rag_core/schemas/rag.py` (`HybridAnswerRequest/HybridAnswerResponse`)
    - `src/agent_parksuite_rag_core/config.py` (`biz_api_base_url/biz_api_timeout_seconds`)
  - tests:
    - `tests/rag_core/test_routes_hybrid_integration.py`
    - uses `data/rag000/scenarios.jsonl` as dataset-driven integration input
    - validates `fee_verify` and `arrears_check` branch execution paths

### RAG-006: Evaluation baseline and seed dataset
- Implementation phases:
  - Phase 1 (dataset first):
    - build evaluation dataset (target 60 queries) in `data/rag006/eval_queries.jsonl`
    - include retrieval/hybrid/negative/boundary cases with expected outputs
  - Phase 2 (report script):
    - implement offline evaluator script (`scripts/rag006_run_eval.py`)
    - replay `/api/v1/retrieve` + `/api/v1/answer/hybrid`
    - output summary and failure reports to `reports/`
  - Phase 3 (engineering hardening):
    - metric threshold gate in CI
    - stable run profile (seed/config/report format)
    - regression comparison between commits
- Baseline metrics:
  - retrieval hit rate
  - citation coverage
  - empty retrieval rate
  - tool call compliance rate
  - answer consistency rate
- Acceptance (phase-wise):
  - Phase 1: dataset schema finalized and sample set available
  - Phase 2: one command generates metric report artifacts
  - Phase 3: CI can block regressions by configured thresholds
- Design doc:
  - `docs/rag006_eval_plan.md`

### RAG-007: Lightweight orchestration refinement (Paused)
- Status: `Paused`
- Reason: current `RAG-005` flow already meets online usage for 3 core scenarios, with `graph_trace` for branch observability.
- Resume trigger:
  - need step-level status trace beyond current branch-level trace, or
  - need measurable latency/maintainability improvement from finer-grained orchestration.
- Goal: keep `RAG-005` simple and optimize for the 3 core user scenarios:
  - `rule_explain`: explain billing rules
  - `arrears_check`: query arrears orders
  - `fee_verify`: verify disputed fee with simulation
- Scope:
  - keep fixed LangGraph topology (no dynamic graph generation)
  - one-time intent routing at request start (avoid per-step LLM routing)
  - add deterministic per-intent step chain:
    - `rule_explain`: `rag_retrieve -> answer_synthesizer`
    - `arrears_check`: `tool_get_arrears -> answer_synthesizer` (RAG optional)
    - `fee_verify`: `tool_get_order -> tool_simulate -> answer_synthesizer` (RAG optional)
  - add lightweight execution trace (`plan_trace`/`graph_trace`) with step status for observability
- Non-goals:
  - no generic planner DSL
  - no mixed-intent multi-branch optimizer in this phase
- Acceptance:
  - no extra LLM calls beyond route/classify + final synthesis
  - each request exposes deterministic executed steps and statuses
  - latency is improved or unchanged compared with current `RAG-005`

### RAG-008: Evaluator-optimizer loop (Paused)
- Status: `Paused`
- Reason:
  - current tool set is small and deterministic, low chance of missing-tool recovery value
  - current dataset scale is limited, retry via larger retrieval window has low marginal gain
  - fact-conflict correction can be covered by lightweight guards instead of full retry loop
- Resume trigger:
  - tool surface expands and mixed workflows increase missed-step risk, or
  - production traffic shows frequent fact-conflict / evidence-insufficient failures
- Add response evaluator after first draft:
  - check evidence sufficiency (citations present and relevant)
  - check tool coverage (required tool calls executed for intent)
  - check consistency between tool facts and generated text
- Add optimizer retry policy:
  - if evaluation fails, auto re-retrieve / re-call missing tools / regenerate once
- Acceptance:
  - failed first-pass answers can be corrected automatically
  - evaluation result is logged with pass/fail reason and retry path

### RAG-009: Multi-turn short-term memory
- Status: `Done` (PR-1 ~ PR-4 completed)
- Goal:
  - support short-term conversational memory for follow-up questions in the same session
  - prioritize deterministic slot carry-over for parking domain (`city_code/lot_code/plate_no/order_no`)
- Scope boundary:
  - only short-term memory (recent turns + extracted slots)
  - no long-term profile memory and no cross-session recall
- PR split:
  - PR-1 (done): acceptance dataset and scenario definition
    - deliver `data/rag009/memory_acceptance_cases.jsonl`
    - cover core multi-turn chains:
      - arrears list -> dispute one order amount
      - missing parameter -> follow-up补参
      - referential follow-up (`第一笔` / `上一单`)
  - PR-2 (done): API/session contract
    - add `session_id` and optional `turn_id` to hybrid request/response schema
    - define turn persistence model and memory TTL
  - PR-3 (done): workflow integration
    - add memory read/write layer before intent routing and tool calls
    - deterministic slot resolution for follow-up questions
  - PR-4 (done): tests + eval
    - integration tests for multi-turn carry-over
    - dataset replay script for short-term memory acceptance
- Acceptance:
  - turn-2/turn-3 can resolve omitted fields from prior turns in same session
  - follow-up referential query can map to deterministic `order_no`
  - response includes memory trace for auditable slot来源
- Implemented in PR-2 (done):
  - schemas:
    - `HybridAnswerRequest`: `session_id`/`turn_id` added
    - `HybridAnswerResponse`: `session_id`/`turn_id`/`memory_ttl_seconds` added
  - route behavior:
    - `/api/v1/answer/hybrid` generates `turn_id` when absent
    - response echoes `session_id`, includes generated/provided `turn_id`
  - config:
    - `RAG_MEMORY_TTL_SECONDS` / `RAG_MEMORY_MAX_TURNS`
  - tests:
    - `tests/rag_core/test_routes_hybrid_integration.py` asserts session contract fields
- Implemented in PR-3 (done):
  - memory service:
    - `src/agent_parksuite_rag_core/services/memory.py`
    - pluggable session memory repository interface + in-memory TTL implementation
  - workflow integration (`run_hybrid_answering`):
    - `memory_hydrate`: carry-over slots (`city_code/lot_code/plate_no/order_no`)
    - reference handling for follow-up (`这笔/上一单`) by clarification short-circuit
    - `memory_persist`: persist slots/turn summary after each turn
  - tests:
    - `tests/rag_core/test_routes_hybrid_memory_integration.py`
    - covers same-session order carry-over and cross-session isolation
- Implemented in PR-4 (done):
  - replay/eval module:
    - `src/agent_parksuite_eval/memory_replay.py`
  - replay script entry:
    - `scripts/rag009_replay_memory_acceptance.py`
  - acceptance dataset:
    - `data/rag009/memory_acceptance_cases.jsonl`
  - doc:
    - `README.md` (RAG-009 Memory Acceptance Replay section)
  - latest acceptance result:
    - replay summary `total_turns=12 passed=12 failed=0`

### RAG-010: Slot extraction + short-circuit clarification (ReAct for ambiguous intent)
- Status: `In Progress` (resolver baseline + deterministic missing-slot short-circuit)
- Goal:
  - add a short-circuit pre-processing stage for hybrid requests:
    - resolve intent + slots in one step
    - separate deterministic business clarification vs ReAct clarification
  - keep existing `RAG-005/RAG-009` business workflow stable for clear-intent cases
- Key requirements:
  - extract current slot-carry-over logic from `hybrid_answering.py` into a dedicated module
  - simplify `HybridAnswerRequest`:
    - keep only minimal user-facing input fields
    - move executable business parameters to resolver output context
  - design one-shot prompt so LLM can output:
    - intent
    - slot extraction
    - missing/ambiguous slot judgment
    - clarification mode decision
    - tool-use suggestion (structured)
  - intent-clear clarification should stay in current business flow
  - intent-ambiguous clarification should be handled by ReAct clarification flow
  - review memory model and adapt only where needed for clarification continuity
- Scope boundary:
  - this phase focuses on clarification routing and slot/intent resolution
  - no broad dynamic planner, no open-ended multi-hop agent loop
  - ReAct path is clarification-only and should short-circuit before heavy biz tool chain
- Short-circuit decision contract (target):
  - `continue_business`:
    - intent is clear and required slots are available
    - continue existing hybrid workflow
  - `clarify_biz`:
    - intent is clear but required slots are missing/ambiguous
    - reuse deterministic business clarification in current flow
  - `clarify_react`:
    - intent is ambiguous/conflicting
    - enter ReAct clarification flow and return clarification question
  - `fallback_rule`:
    - LLM/tool failure in pre-stage, fallback to deterministic rule route
- Proposed module split:
  - request/execute contract split:
    - keep external request schema minimal (`session_id/turn_id/query` + optional hints)
    - introduce internal resolved context (intent + slots + clarify decision) for downstream tools/workflow
    - preserve backward compatibility in transition window, then deprecate direct business slot fields in request
  - new service:
    - `src/agent_parksuite_rag_core/services/intent_slot_resolver.py`
    - responsibilities:
      - slot inheritance (from memory)
      - slot extraction (from current query)
      - intent resolution + confidence + clarification mode output
  - new prompt assets:
    - `src/agent_parksuite_rag_core/prompts/intent_slot_react.md`
  - `hybrid_answering.py` becomes orchestrator:
    - call resolver first
    - short-circuit by resolver decision
    - keep existing graph for `continue_business`
- Memory adaptation plan:
  - keep `SessionMemoryRepo` interface unchanged
  - extend `SessionMemoryState` with optional clarification context fields:
    - `pending_clarification`
    - `clarification_context`
    - `slot_candidates` (generalized from order-only candidates)
    - `last_user_confirmed_slots`
  - persist only structured clarification artifacts; do not persist hidden reasoning text
- PR split (recommended):
  - PR-1: pure refactor + contract preparation
    - move slot inheritance/extraction code to resolver module
    - add internal resolved context model and adapter from current request
    - no behavior change
  - PR-1b: memory simplification cleanup (feature removal)
    - remove `last_intent` and `order_candidates` from `SessionMemoryState`
    - remove automatic intent carry-over and candidate-based order reference resolution
    - keep only deterministic slot carry-over and explicit clarification short-circuit
  - PR-1c: remove pre-ReAct quick intent inference in resolver
    - remove `_apply_memory_hydrate` quick intent forcing (`intent_hint` writeback)
    - keep resolver focused on slot hydrate and clarification gating only
    - ensure intent authority is unified in ReAct intent decision stage
  - PR-2: one-shot LLM resolve
    - add prompt + parser + short-circuit decision object
    - start shrinking `HybridAnswerRequest` surface (deprecate direct business slot inputs)
    - wire resolver output into hybrid entry
  - PR-3: ReAct clarification path
    - add clarification-only ReAct flow for ambiguous intent
    - add memory adaptation for pending clarification continuation
  - PR-4: tests + replay
    - add integration tests for:
      - clear intent + missing slot -> `clarify_biz`
      - ambiguous intent -> `clarify_react`
      - clear intent + full slots -> `continue_business`
      - fallback behavior on LLM/tool errors
- Acceptance:
  - `HybridAnswerRequest` is minimal and caller-friendly; business execution slots are resolver-owned
  - clear-intent requests should not introduce extra ReAct latency path
  - ambiguous-intent requests should return actionable clarification question deterministically
  - existing hybrid and RAG-009 memory tests keep passing (no regression)
  - new graph/memory traces clearly show short-circuit decision and clarification source
- Implemented (current):
  - `intent_slot_resolver` deterministic pipeline wired in:
    - `intent_slot_parse -> slot_hydrate -> react_clarify_gate`
  - resolver async entry added for one-shot parse path:
    - `resolve_turn_context_async` with `LLM one-shot -> deterministic fallback`
    - keep sync `resolve_turn_context` for deterministic/unit-level usage
  - missing required slot now short-circuits in resolver gate:
    - `fee_verify` missing `order_no` -> `clarify_biz`
    - `arrears_check` missing `plate_no` -> `clarify_biz`
  - route keeps backward-compatible response schema; short-circuit surfaced via `business_facts.error`
  - PR-A progress:
    - resolver chain now runs for all hybrid requests (with or without `session_id`)
    - `session_id` only controls memory read/write path
  - PR-B progress:
    - downstream hybrid classifier now consumes resolver-resolved intent first
    - removed LLM-based second intent arbitration in `hybrid_answering`
  - PR-C progress:
    - introduced internal `ResolvedExecutionContext` (intent + slots + field_sources)
    - short-circuit branch now reads resolved slots from execution context instead of direct payload introspection
    - biz tool input now uses internal execution context (`BizExecutionContext`) instead of direct request coupling
    - `run_hybrid_workflow` payload switched to `HybridExecutionContext` (internal), route/service adapted with request-compatible mapping
  - PR-D progress:
    - removed `clarify_tool_trace` persistence from session memory
    - keep runtime/debug response tool trace, but do not store it in memory state
    - moved `/debug/intent-slot-parse` and `/debug/clarify-react` into dedicated `api/debug_routes.py`
    - production routes module now focuses on online serving path only

#### RAG-010 PR-3 Design (ReAct Clarification Loop)
- Goal alignment:
  - replace current rule-only `_react_clarify_gate` with ReAct-based clarification orchestration
  - ReAct is triggered only when `_intent_slot_parse + _slot_hydrate` still cannot converge
  - ensure multi-turn clarification can carry full chat/tool history into next LLM calls
- Trigger conditions to enter ReAct:
  - `intent` is still `None` (ambiguous/conflicting intent)
  - intent is clear but `missing_required_slots` is not empty
  - slot value exists but requires validation before business execution (e.g. `order_no`/`plate_no`)
- Resolver decision contract (PR-3):
  - `continue_business`: intent clear + required slots present + validation passed (if needed)
  - `clarify_react`: need user clarification and/or tool validation loop
  - `clarify_abort`: max rounds reached or still cannot converge deterministically
- ReAct loop responsibilities:
  - ask user targeted clarification question (`ask_user`)
  - optionally call validation tools, then continue reasoning within one invocation
  - output strict structured JSON:
    - `action`: `ask_user|finish_clarify|abort`
    - `clarify_question`: string|null
    - `slot_updates`: object
    - `reason`: string|null
- Clarification tools (initial set):
  - `validate_order_no(order_no, city_code, lot_code)` -> `{valid, canonical_order_no, reason}`
  - `validate_plate_no(plate_no, city_code)` -> `{valid, canonical_plate_no, reason}`
  - `lookup_order_or_lot(query, candidates)` -> `{order_hit, lot_hit, order_no, lot_code, confidence, reason}`
  - (optional) `suggest_candidates(...)` for weak-match hints
- Session memory adaptation (interface unchanged, state extended):
  - `clarify_messages`: persisted `system/user/assistant/tool` messages for next-turn replay
  - `pending_clarification`: `{intent_candidate, required_slots, rounds, last_question}`
  - `resolved_slots`: user-confirmed and tool-validated slots
  - keep persistence structured only; no hidden reasoning text
- Per-turn runtime flow:
  - Step-1/2 run first: `_intent_slot_parse -> _slot_hydrate`
  - if unresolved, invoke ReAct clarification (`run_clarify_react_once`)
  - persist returned `messages/resolved_slots/pending_clarification`
  - if `ask_user`, return clarification question immediately
  - if `finish_clarify`, merge slots back to payload and continue existing hybrid workflow
- Ambiguous second-turn resolution (new):
  - scenario: turn-1 intent ambiguous & no slots -> enter ReAct ask_user
  - turn-2 user gives ambiguous parameter (could map to order or lot)
  - ReAct should perform dual lookup tools (order first, then lot or parallel) to disambiguate:
    - only `order_hit` -> route `fee_verify`
    - only `lot_hit` -> route `rule_explain`
    - both hit -> ask a targeted follow-up question
    - none hit -> ask for clearer identifier
- Safety and loop controls:
  - configurable `max_clarify_rounds` (default 3)
  - if repeated no-progress rounds -> `clarify_abort`
  - only validated slots are allowed to drive downstream business tools
- Integration boundary:
  - keep existing `RAG-005/RAG-009` business workflow unchanged for clear-intent requests
  - ReAct path is clarification-only and should short-circuit before heavy business chain

#### RAG-010 Refactor Plan (Complexity Control)
- Goal:
  - keep `slot_parse + slot_hydrate + react_clarify` capabilities
  - reduce architecture complexity by enforcing single entry / single authority / clear boundaries
- PR-A: unify resolver entry (in progress)
  - all hybrid requests must run through:
    - `intent_slot_parse -> slot_hydrate -> react_clarify_gate`
  - `session_id` only controls memory read/write, not whether resolver runs
  - acceptance:
    - no-session and with-session requests use same pre-processing chain
    - short-circuit behavior is consistent across session modes
- PR-B: single intent authority
  - intent authority moves to resolver/ReAct stage only
  - downstream hybrid business flow consumes resolved intent; no second intent arbitration
  - acceptance:
    - one request has one final intent source
    - remove intent conflict between resolver and hybrid classifier
- PR-C: request/execute contract split
  - external `HybridAnswerRequest` stays minimal
  - internal execution uses resolved context model (`intent + slots + decision + source tags`)
  - acceptance:
    - biz tools/workflow no longer directly depend on bloated request fields
- PR-D: memory/debug slimming
  - memory stores only minimal runtime state:
    - `slots`, `turns`, `pending_clarification` (and strictly required structured artifacts)
  - debug/replay artifacts are decoupled from production critical path
  - acceptance:
    - memory payload size and coupling are reduced
    - debug capability remains available via dedicated path

## Open items
- Define and document `rule_payload` schema contract more strictly (JSON Schema / Pydantic typed segments)

### RAG-011: Clarify Sub-Agent Boundary Refactor
- Status: `Done` (PR-1 ~ PR-5 completed)
- Goal:
  - treat ReAct clarification as an independent sub-agent
  - simplify main hybrid flow by using task-in / result-out contract
  - isolate clarification memory/context from production business execution path
- Problem statement:
  - current clarification path still leaks process-level data (`messages`, traces, tool traces) into outer layers
  - `run_clarify_react_once` and surrounding orchestration carry mixed responsibilities (agent loop + state transfer + business integration)
- Target architecture:
  - external orchestrator calls a single entry:
    - `run_clarify_task(task) -> result`
  - sub-agent internalizes:
    - ReAct loop
    - short-term clarify memory
    - tool reasoning traces
  - outer system only consumes:
    - decision (`continue_business|ask_user|abort`)
    - clarify question
    - slot updates / resolved intent
    - missing required slots
- Contract proposal:
  - `ClarifyTask`:
    - `query`
    - `known_slots`
    - `required_slots`
    - `intent_hint` (optional)
    - `session_key` (optional, for clarify memory namespace)
  - `ClarifyResult`:
    - `decision`
    - `clarify_question`
    - `slot_updates`
    - `resolved_intent` (optional)
    - `missing_required_slots`
    - `meta` (lightweight diagnostics only)
- Memory boundary:
  - sub-agent memory:
    - private clarify history
    - tool-level intermediate context
  - outer session memory:
    - only stable artifacts (`slots`, `pending_clarification`, summarized resolved result)
  - non-goal:
    - persist full ReAct internal trace in production memory state
- PR split (recommended):
  - PR-1: sub-agent contract scaffold
    - add `ClarifyTask` / `ClarifyResult` schema
    - add `ClarifyAgent` interface and adapter over existing `run_clarify_react_once`
    - keep behavior unchanged
    - implemented:
      - new file `services/clarify_agent.py` (`ClarifyTask`, `ClarifyResult`, `ClarifyAgent`, `ReActClarifyAgent`)
      - `react_clarify_gate_async` now invokes `ClarifyAgent` contract instead of direct graph function
  - PR-2: internal clarify memory encapsulation
    - move clarify message serialization/deserialization into sub-agent module
    - remove direct memory plumbing from route/service layer
    - implemented:
      - `run_clarify_react_once` now accepts `history_messages` instead of `memory_state`
      - clarify history deserialize/serialize moved to `services/clarify_agent.py`
  - PR-3: orchestration simplification
    - `react_clarify_gate_async` consumes `ClarifyAgent` result only
    - remove process-level fields from gate return path where unnecessary
    - implemented:
      - gate internal flow switched from `dict` relay to typed `ClarifyResult` relay
      - main resolver/hybrid path no longer propagates `clarify_tool_trace` (debug path keeps tool trace)
  - PR-4: production/debug path separation
    - production returns stable decision payload only
    - debug endpoints fetch optional deep traces from sub-agent debug adapter
    - implemented:
      - removed `tool_trace` from clarify workflow/agent/gate/debug response end-to-end
      - clarify memory persistence tightened:
        - `clarify_messages` is persisted only when `pending_clarification` exists
        - clarified-to-business turn clears pending clarify artifacts in session memory
  - PR-5: cleanup + migration
    - delete obsolete fields/branches and update replay scripts/tests
    - implemented:
      - removed clarify persistence artifacts from `business_facts` response payload
      - removed `resolved_slots` from clarify response `business_facts` (memory still persists via internal context)
      - session memory persistence now takes internal clarify context via explicit parameters
- Acceptance:
  - hybrid main flow no longer depends on raw clarify messages/tool traces for normal execution
  - clarify module can be tested independently via task/result contract
  - production memory payload is reduced and stable
  - existing hybrid behavior remains compatible for user-visible outputs

### RAG-012: Tool-evidence Intent Convergence in ReAct
- Status: `In Progress` (PR-1 ~ PR-3 implemented)
- Goal:
  - keep `intent_slot_parse -> slot_hydrate` as fast pre-stage
  - enter Clarify Sub-Agent only when intent is ambiguous/conflicting or required slots are missing
  - let ReAct output explicit intent convergence result based on tool evidence
  - remove downstream second intent arbitration and keep one final authority
- Why:
  - current gate still has fallback heuristics after ReAct in some branches
  - intent semantics and execution routing should be unified under one contract
- Scope:
  - preserve current clear-intent + short-circuit behavior
  - converge ambiguous/missing-slot path via Clarify Sub-Agent contract
- Contract changes:
  - Clarify Sub-Agent result contract (normalized):
    - `resolved_intent`: `rule_explain|arrears_check|fee_verify|null`
    - `decision`: `continue|ask|abort`
    - `route_target`: same value as `resolved_intent` (explicitly `route_target = intent`)
    - `slot_updates`: resolved slot delta
    - `intent_evidence`: optional short labels (e.g. `lookup_order_hit`, `billing_rules_hit`)
  - extend `ClarifyResult` with:
    - `resolved_intent: str | None`
    - `route_target: str | None`
    - `slot_updates: dict[str, Any]`
    - `intent_evidence: list[str]`
- Decision policy:
  - gate accepts Sub-Agent intent only when:
    - `decision=continue`
    - `resolved_intent` is in valid intent set
    - `route_target == resolved_intent`
  - fallback policy:
    - if `resolved_intent` missing/invalid, keep existing missing-intent clarification
  - guardrail:
    - no confidence-score based branching
    - intent must be backed by tool evidence or explicit deterministic rule
- PR split:
  - PR-1: contract/schema plumbing
    - update clarify prompt JSON contract to include `resolved_intent`/`route_target`/`slot_updates`/`intent_evidence`
    - parse and carry fields through `clarify_react_graph -> ClarifyResult`
    - implemented:
      - clarify prompt/JSON parser now carries `resolved_intent`/`route_target`/`slot_updates`/`intent_evidence`
      - `ClarifyResult` extended with the same contract fields
  - PR-2: gate integration
    - `react_clarify_gate` consumes `ClarifyResult.resolved_intent` and `route_target`
    - enforce `route_target = intent` contract and remove residual heuristic arbitration
    - implemented:
      - removed gate-side tool-hit trace inference fallback
      - gate now uses ReAct contract as primary intent source for `continue_business`
      - added contract mismatch guard (`intent_route_mismatch`) and unit coverage
  - PR-3: downstream routing unification
    - resolver/hybrid route consumes contract output directly; no second intent arbitration
    - ensure debug API reports final converged intent and route target consistently
    - implemented:
      - removed downstream `rule_explain` fallback arbitration in `hybrid_answering` route path
      - when contract is missing final intent, route returns clarify-style contract error (`missing_intent_contract`)
      - gate blocks `continue_business` when intent is still missing in ambiguous branch
      - debug clarify response now includes `route_target` for intent-route consistency check
  - PR-4: tests + acceptance
    - add unit/integration cases:
      - ambiguous intent + order tool hit -> `resolved_intent=arrears_check`, `route_target=arrears_check`
      - ambiguous intent + billing rule tool hit -> `resolved_intent=rule_explain`, `route_target=rule_explain`
      - no valid evidence -> `missing_intent` clarify
      - contract mismatch guard (`route_target != intent`) -> fallback clarify
    - add log assertions for intent evidence and contract traceability
- Acceptance:
  - ambiguous requests can continue business when tool evidence is sufficient
  - no intent-confidence threshold is used in routing
  - one request has one final intent authority after gate normalization
  - `route_target` is always equal to final `intent` in this phase
